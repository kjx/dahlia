//somewhat cleaned up version
//non-working / non-useful, non-required code REMOVED
//useful, non-required code COMMENTED
//useful, required code KEPT


class Object {

  const bound : Owner //movement bound - stands in for explcit owner parameters
  const AMFB  : Owner //flattened bound

  const owner : Owner//actual "dynamic" Owner owner of this object --- *XTERNAL*
  const AMFX :  Owner//flattened owner  /// aka all externeal owners

  const ntrnl : Owner //internal owners - i.e. Self-ownership - i.e. includers THIS
  const AMFO  : Owner //All MY FUCKING Owner  (aka All My Flat Owner:-)


constructor {:isolate_assertions} bake(oo : Owner, mb : Owner)
  requires oo >= mb
  requires forall o <- mb :: o.Ready()
  requires forall o <- oo :: o.Ready()
  requires forall o <- oo, ooo <- o.AMFO :: o.AMFO > ooo.AMFO

  ensures mb == bound
  ensures oo == owner
  ensures ntrnl > owner >= bound
  ensures (forall o <- oo ::   o.Ready())
  ensures (forall o <- bound ::   o.Ready())

  ensures fresh(this)
  ensures Ready()
  modifies {}
  {
    bound := mb;
    owner := oo;
    ntrnl := oo + {this};

    AMFB  := (set o <- mb, x <- o.AMFO :: x);
    AMFX  := (set o <- oo, x <- o.AMFO :: x);
    AMFO  := (set o <- oo, x <- o.AMFO :: x) + {this};

new;

    // assert
    // && (AMFB == (set o <- bound, oo <- o.AMFO :: oo)) //hmm...
    // && (AMFX == (set o <- owner, oo <- o.AMFO :: oo))
    // && (AMFO == (set o <- ntrnl, oo <- o.AMFO :: oo) +  {this})
    // ;

    // assert AMFB  == flatten(mb);
    // assert AMFX  == flatten(oo);
    // assert AMFO  == flatten(oo) + {this};

    assert
    && (forall oo <- owner :: oo.AMFO < AMFO)
    && (forall oo <- bound :: oo.AMFO < AMFO)
    && (forall oo <- owner :: oo.Ready())
    && (forall oo <- bound :: oo.Ready())
    ;

assert forall o <- owner, ooo <- o.AMFO :: o.AMFO > ooo.AMFO;
assert forall oo <- AMFO :: oo.AMFO <= AMFO;

}



predicate Ready()
   reads {}
   decreases AMFO, 20
  {
    && (AMFB == flatten(bound))
    && (AMFX == flatten(owner))
    && (AMFO == (flatten(ntrnl - {this}) + {this}))
    && (AMFO == (flatten(owner) + {this}))
    && (AMFO == AMFX + {this})
    && (AMFX == AMFO - {this})


    && (this !in AMFB)
    && (this !in AMFX)
    && (this  in AMFO)

    && (AMFO > AMFX >= AMFB)

    && (forall oo <- owner :: AMFO > oo.AMFO)
    && (forall oo <- bound :: AMFO > oo.AMFO)
    && (forall oo <- owner :: oo.Ready())
    && (forall oo <- bound :: oo.Ready())

    && (forall oo <- owner :: (AMFO > oo.AMFO) && oo.Ready())

    && (forall oo <- AMFO :: AMFO >= oo.AMFO)
//    && (forall o <- owner, ooo <- o.AMFO :: AMFO >= o.AMFO >= ooo.AMFO)
    && (forall o <- AMFO, ooo <- o.AMFO :: AMFO >= o.AMFO >= ooo.AMFO)
  }

}//end class Object

//unnecessary lemma?
lemma MoreValidThanValid(o : Object)
  requires o.Ready()
  ensures  o !in o.AMFB
  ensures  o !in o.AMFX
  ensures  o  in o.AMFO
{}

//owners

type Owner = set<Object>

function flatten(os : Owner) : Owner {(set o <- os, oo <- o.AMFO :: oo) + os}
function flattenBound(os : Owner) : Owner {set o <- os, oo <- o.AMFB :: oo}

//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//
//  Geometric lemata
//
//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//
// core geometry
//

// definitions of inside

predicate inside(part : Object, whole : Object) : (rv : bool)  { part.AMFO >= whole.AMFO }

predicate outside(part : Object, whole : Object) : (rv : bool) { not(inside(part,whole)) }

// lemma Inside3(a : Object, b : Object, c : Object)
//   requires inside(a,b)
//   requires inside(b,c)
//   ensures  inside(a,c)
// {}


//interobejct references

predicate refBI(f : Object, t : Object) {f.AMFB >= t.AMFX}
predicate refDI(f : Object, t : Object) {f.AMFO == t.AMFX}
predicate refOK(f : Object, t : Object) {(f==t) || refBI(f,t) || refDI(f,t)}

// //diversion -BI & DI definitions cross with flattness
// predicate fefBI(f : Object, t : Object) {flatten(f.bound) >= flatten(t.owner)}
//
// lemma recBIvsfefBI(f : Object, t : Object)
//   requires f.Ready()
//   requires t.Ready()
//   ensures refBI(f,t) == fefBI(f,t)
// {}
//
// lemma recBIvsFLAT(f : Object, t : Object)
//   requires f.Ready()
//   requires t.Ready()
//   ensures (f.AMFB >= t.AMFX) <==> (flatten(f.bound) >= flatten(t.owner))
//   ensures refBI(f,t) == fefBI(f,t)
// {}
//
// lemma recDIvsFLAT(f : Object, t : Object)
//   requires f.Ready()
//   requires t.Ready()
//   ensures (f.AMFO == t.AMFX) ==> ((flatten(f.ntrnl - {f}) + {f})  == flatten(t.owner))
// {}
//
//
// lemma refBI_nesting(a : Object, b : Object, c : Object, m : SuperKlon)
//   requires a.Ready()
//   requires b.Ready()
//   requires c.Ready()
//
//   requires refBI(a,b)
//
//   ensures  (a.AMFO > a.AMFX >= a.AMFB)
//   ensures  (b.AMFO > b.AMFX >= b.AMFB)
//   ensures  a.AMFB >= b.AMFX
//   ensures  (a.AMFO > a.AMFX >= a.AMFB >= b.AMFX >= b.AMFB)
//   ensures  a.AMFB >= b.AMFB
// {}
//
// lemma refBI_transitive(a : Object, b : Object, c : Object, m : SuperKlon)
//   requires a.Ready()
//   requires b.Ready()
//   requires c.Ready()
//
//   requires refBI(a,b)
//   requires refBI(b,c)
//
//   ensures  refBI(a,c)
// {}
//
//end diversion


//
// derived lemmas equality etc
//

lemma AXIOMAMFOS(a : Object, b : Object)
// equal AMFOs iff same objects
  requires a.Ready()
  requires b.Ready()
  ensures  (a == b)  ==> (a.AMFO == b.AMFO)
  ensures  (a == b) <==  (a.AMFO == b.AMFO)
  ensures  (a == b) <==> (a.AMFO == b.AMFO)
{}


lemma AXIOMAMFO(part : Object, whole : Object)
// o in AMFO ==> o.AMFO <= AMFO
   requires  part.Ready()
   requires  {whole}    <= part.AMFO
   ensures   whole.AMFO <= part.AMFO
   ensures   inside(part,whole)
   {
    AMFOsisAMFOs(part);
   }

lemma AXIOMAMFOREVERSE(part : Object, whole : Object)
// inside(part,whole) ==> whole in part.AMFO
   requires   part.Ready()
   requires   whole.Ready()
   requires   part.AMFO >= whole.AMFO

   requires   inside(part,whole)
   ensures    whole in part.AMFO
   {
    assert whole in whole.AMFO;
    AMFOsisAMFOs(part);
   }

//
// inside vs inside
//

predicate recInside(part : Object, whole : Object) : (r : bool)
    requires part.Ready()
    decreases part.AMFO
{
  || (part == whole)
  || (exists x <- part.owner :: recInside(x,whole))
}

function collectAllOwners(o : Object) : (rv : Owner)
  decreases o.AMFO
  requires o.Ready()
{
  {o} + o.owner + (set xo <- o.owner, co <- collectAllOwners(xo) :: co)
}

lemma collectAllAMFO(o : Object)
  decreases o.AMFO
  requires  o.Ready()
  ensures   o.AMFO == collectAllOwners(o)
  {}

lemma recInsideCollectsAllOwners1(part : Object, whole : Object)
  decreases part.AMFO
  requires part.Ready()
  requires recInside(part,whole)
  ensures  (whole in collectAllOwners(part))
{}

lemma recInsideCollectsAllOwners2(part : Object, whole : Object)
  decreases part.AMFO
  requires part.Ready()
  ensures recInside(part,whole) <== (whole in collectAllOwners(part))
{}


// lemma recInsideAMFO1(part : Object, whole : Object)
//   decreases part.AMFO
//   requires part.Ready()
//   requires whole.Ready() //why not?
//
//   requires (whole in part.AMFO)
//   ensures  recInside(part,whole)
// {}
//
// lemma recInsideAMFO2(part : Object, whole : Object)
//   decreases part.AMFO
//   requires  part.Ready()
//   requires  whole.Ready() //why not?
//   requires  recInside(part,whole)
//   ensures   (whole in part.AMFO)
// {}
//
//
// lemma InsideRecInside2(part : Object, whole : Object)
//    requires part.Ready()
//    requires whole.Ready() //why not?
//    requires    inside(part,whole)
//    ensures  recInside(part,whole)
//    {
//     assert  inside(part,whole);
//     assert  part.AMFO >= whole.AMFO;
//     AXIOMAMFOREVERSE(part,whole);
//     assert whole in part.AMFO;
//     collectAllAMFO(part);
//     assert (whole in collectAllOwners(part));
//     recInsideCollectsAllOwners2(part,whole);
//     assert recInside(part,whole);
//    }
//
// lemma InsideRecInside1(part : Object, whole : Object)
//    requires part.Ready()
//    requires whole.Ready() //why not?
//    requires recInside(part,whole)
//    ensures  inside(part,whole)
//    {
//       recInsideCollectsAllOwners1(part,whole);
//       assert (whole in collectAllOwners(part));
//       collectAllAMFO(part);
//       assert (whole in part.AMFO);
//       AXIOMAMFO(part, whole);
//    }



lemma AMFOsisAMFOs(o : Object)
   requires o.Ready()
   ensures forall oo <- o.AMFO | oo != o :: (o.AMFO > oo.AMFO)
{}


///////////////////////////////////////////////////////////////////////////////////////////
// the Pointing Lemmas
///////////////////////////////////////////////////////////////////////////////////////////
//
// lemma
// INSIDE_CAN_POUNT_OUT(m' : Klon, f : Object, t : Object, o : Object, c : Object)
//  requires f.Ready()
//  requires o.Ready()
//  requires t.Ready()
//  requires inside(f,o)
//  requires outside(t,o)
//  //requires |f.AMFO| == |o.AMFO| + 100   ///arbitrarily deep
//
//  requires refOK(o,t)
//  requires f.AMFB >= t.AMFX
//  ensures  refOK(f,t)
// {
//   // assert refOK(o,t);
//
// //   assert (o==t) || refBI(o,t) || refDI(o,t);
// //
// //   assert (o != t);
// //
// //   if (refDI(o,t)) {
// //       assert {:contradiction} o.AMFO == t.AMFX;
// //       assert {:contradiction} t.AMFO == (t.AMFX + {t});
// //       assert {:contradiction} t.AMFO > o.AMFO;
// //       assert {:contradiction} inside(t,o);
// //       assert {:contradiction} false;
// //       return;
// //   }
//
//   // assert refBI(o,t); //only remaining case
//   // assert o.AMFB >= t.AMFX;
//   // assert f.AMFB >= t.AMFX;
//
//   // assert refOK(f,t);
// }
//
// lemma
//  MOVING_ON_IN(m' : Klon, f : Object, t : Object, o : Object, c : Object)
// /// can move an object down; doesn't lose access
//  requires f.Ready()
//  requires o.Ready()
//  requires t.Ready()
//  requires inside(c,o) && (c != o)
//  requires inside(f,c) && (f != c)
//  requires |f.AMFO| == |o.AMFO| + 100
//  requires refOK(o,t)
//  requires outside(t,o)
//  requires f.AMFB >= t.AMFX
//
//  ensures refOK(f,t)
// {}
//
// lemma outsideAINTEQUALS(a : Object, b : Object)
//   requires outside(a,b)
//   ensures  a != b
//   {}
//
//
// lemma InsideOutsideAINTEQUALS(a : Object, b : Object, o : Object)
//   requires a.Ready()
//   requires b.Ready()
//   requires o.Ready()
//   requires inside(a,o)
//   requires outside(b,o)
//   ensures  a != b
//   {}
//
// lemma NO_INCOMING_REFS(f : Object, t : Object, o : Object)
//  requires f.Ready()
//  requires o.Ready()
//  requires t.Ready()
//  requires outside(f,o) //&& (f != o) //unnecessary
//  requires inside(t,o)  && (t != o) //perhaps, perhaps, perhaps  //ieStrictlyInside
//
//  ensures not( refOK(f,t) )
//  ensures f != t
// {
// }
//
// lemma INCOMING_REFS_OWNER_ONLY(f : Object, t : Object, o : Object)
//  requires f.Ready()
//  requires o.Ready()
//  requires t.Ready()
//  requires outside(f,o) //&& (f != o) //unnecessary
//  requires inside(t,o)  //&& (t != o) //perhaps, perhaps, perhaps  //ieStrictlyInside
//  requires refOK(f,o)
//  requires refOK(f,t)
//  ensures  t == o
//  ensures f != t
// {}



//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]

datatype Klon = Klon
(
  m : vmap<Object,Object>,    //the  klon map
  c : set<Object>,            //context -was oHeap / oHeap+ns
  o_amfo : Owner,             //was o. so the AMFO of o
  c_amfo : Owner              //epected ownershio of the clone..
)
{
    predicate from(prev : Klon)
  {
    && mapGEQ(m, prev.m)
    && o_amfo == prev.o_amfo
    && c_amfo == prev.c_amfo
    && c == prev.c
  }
}


// type SuperKlon = m : Klon | wexford2(m)  witness  Klon(map[], {}, {}, {})


function  klonKV(m' : Klon, k : Object, v : Object) : (m : Klon)
  requires k !in m'.m.Keys
  requires v !in m'.m.Values
{
m'.(m:=m'.m[k:=v])  //l.(m:=l.m[k:=v])
}

function mapThruKlon(os: set<Object>, m : Klon) : (r : set<Object>)
  //image of os under klon mapping m
  // reads m.m.Keys`fields, m.m.Keys`fieldModes
  // reads m.m.Values`fields, m.m.Values`fieldModes
  requires os <= m.m.Keys
{ set o <- os :: m.m[o] }



//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//[[[[[[[[[[
//[[[[[[[[[[  Add Link...
//[[[[[[[[[[
//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//
// this is a bit nuts isn't it?
//
//
//
//
// // FUCK which of thse actua;y work
//
//
// lemma kvdArmedStruggle(m' : Klon, k : Object, v : Object, of : Object, ot : Object, cf : Object, ct: Object, m : Klon)
// //refDI(k,ot) case
//
//   requires k !in m'.m.Keys
//   requires v !in m'.m.Values
//   requires m == klonKV(m',k,v)
//
//   requires (of != ot)
//   requires GRURK: (of != ot)
//
//   requires (refDI(of,ot) && (of == k))
//
//   requires {of, ot} <= m.m.Keys
//   requires m.m[of] == cf
//   requires m.m[ot] == ct
//
//   requires k.Ready()
//   requires v.Ready()
//   requires forall k <- m'.m.Keys :: k.Ready() && m.m[k].Ready()
//
//   requires allmagic2(m')
//   requires magic2(k,v,m')
// //  ensures  allmagic2(m)
//
//   requires dexford4(m')
//
//   // ensures  dexy_NO_builtin(of,ot,cf,ct,m)
//   //  ensures  refOK(of,ot) ==> refOK(cf,ct)
//   {
//
//
// //     assert of != ot;
// //     assert (of == k) != (ot == k);
// //     //from here on, of one of and ot is k, the other is not
//
// //  if (refDI(of,ot) && (of == k)) {//refDI(k,ot)
// //    assert of != ot by { reveal GRURK; }
//
//     // assert of.AMFO == ot.AMFX;  //by defn DI
//
//   // //  //  kdvDIKN(m', k, v, of, ot, cf, ct, m);
//
// //     if (k == v) {
// //       assert not(of.AMFO >= m.o_amfo); //k outside
// //       assert of == cf == v == k; //k outside
// //       // assert refOK(k,v);
// //       // assert ct == m.m[ot];
// //       // assert magic(ot,ct,m);
// //
// //       assert of.AMFO == ot.AMFX;  //ref defin DI
// //       assert of.AMFO != m.o_amfo;
// //
// //       assert not(of.AMFO >= m.o_amfo);
// //
// //       if (ot.AMFX == m.o_amfo) { //directly inside
// //           assert ((ot != ct) && (ct.AMFX == m.c_amfo));
// //           assert refOK(of,ot);
// //           assert refOK(cf,ct);
// //         } else  {
// //           assert refOK(cf,ct);
// //           assert (refOK(of,ot) ==> refOK(cf,ct));
// //         }
// //
// //       assert (refOK(of,ot) ==> refOK(cf,ct));
//       // }
// //      else {
// //         assert ((v != k) && (v.AMFO >= m.c_amfo));  //inside & cloned
// //
// //         assert (refOK(of,ot) ==> refOK(cf,ct));
// //       }
// //         assert refOK(v,ct);
// //         assert wexy_NO_builtin(of,ot,cf,ct,m);
//                 }
// //     }
// //     }
// //
// //   }
//
//
//
//
//
//
//
// lemma kvdOTHER(m' : Klon, k : Object, v : Object, of : Object, ot : Object, cf : Object, ct: Object, m : Klon)
// //OTHER case!
//
//   requires k !in m'.m.Keys
//   requires v !in m'.m.Values
//   requires m == klonKV(m',k,v)
//
//   requires {of, ot} <= m.m.Keys
//   requires m.m[of] == cf
//   requires m.m[ot] == ct
//
//   requires k.Ready()
//   requires v.Ready()
//   requires forall k <- m'.m.Keys :: k.Ready() && m.m[k].Ready()
//
//   requires allmagic2(m')
//   requires magic2(k,v,m')
//   ensures  allmagic2(m)
//
//   requires dexford4(m')
//
//   // ensures  dexy_NO_builtin(of,ot,cf,ct,m)
//   //  ensures  refOK(of,ot) ==> refOK(cf,ct)
//   {
//
//
//   }
//
//
//
//
//
//
//
//
//
//
//
//
// lemma {:isolate_assertions} kvdNOTKK(m' : Klon, k : Object, v : Object, of : Object, ot : Object, cf : Object, ct: Object, m : Klon)
//
//   requires ((of != k) && (ot != k))
//
//   requires k !in m'.m.Keys
//   requires v !in m'.m.Values
//   requires m == klonKV(m',k,v)
//
//   requires {of, ot} <= m.m.Keys
//   requires m.m[of] == cf
//   requires m.m[ot] == ct
//
//   requires k.Ready()
//   requires v.Ready()
//   requires forall k <- m'.m.Keys :: k.Ready() && m.m[k].Ready()
//
//   requires allmagic2(m')
//   requires magic2(k,v,m')
//   ensures  allmagic2(m)
//
//   requires dexford4(m')
// //  ensures  dexford4(m)
//
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m)
//   ensures  refOK(of,ot) ==> refOK(cf,ct)
// {
//   //the following is there, and works, and is slower than nothing
// //   assert v == m.m[k];
// //   assert forall mm <- m'.m.Keys :: m'.m[mm]  == m.m[mm];
// //   assert forall mm <- m.m.Keys :: ((mm in m'.m.Keys) ==> (m'.m[mm] == m.m[mm]));
// //   assert m.m.Keys == m'.m.Keys + {k};
// //
// //    assert allmagic2(m');
// //    assert forall mm <- m'.m.Keys       :: magic2(mm, m.m[mm], m);
// //    assert magic2(k,v,m);
// //    assert forall mm <- {k}             :: magic2(mm, m.m[mm], m);
// //    assert forall mm <- m'.m.Keys + {k} :: magic2(mm, m.m[mm], m);
// //    assert forall mm <- m.m.Keys        :: magic2(mm, m.m[mm], m);
// //    assert allmagic2(m);
// }
//
//
// predicate kvdReqs(m' : Klon, k : Object, v : Object, of : Object, ot : Object, cf : Object, ct: Object, m : Klon)
// {
//   && k !in m'.m.Keys
//   && v !in m'.m.Values
//   && m == klonKV(m',k,v)
//
//   && {of, ot} <= m.m.Keys
//   && m.m[of] == cf
//   && m.m[ot] == ct
//
//   && k.Ready()
//   && v.Ready()
//   && (forall k <- m'.m.Keys :: k.Ready() && m.m[k].Ready())
//
//   && allmagic2(m')
//   && magic2(k,v,m')
//
//   && dexford4(m')
// }
//
//
// lemma kvdEQKK(m' : Klon, k : Object, v : Object, of : Object, ot : Object, cf : Object, ct: Object, m : Klon)
//
//   requires (of == ot == k)
//
//   requires kvdReqs(m',k,v,of,ot,cf,ct,m)
//
//   ensures  allmagic2(m)
//
//   //requires dexford4(m')
// //  ensures  dexford4(m)
//
//   ensures refOK(of,ot)
//   ensures refOK(cf,ct)
//
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m)
//   ensures  refOK(of,ot) ==> refOK(cf,ct)
// {}
//
//
// lemma kvdOO(m' : Klon, k : Object, v : Object, of : Object, ot : Object, cf : Object, ct: Object, m : Klon)
//
//   requires not(of.AMFO >= m'.o_amfo) //needs an o_o so we can write outside (later versions faked it up with an argument)
//   requires not(ot.AMFO >= m'.o_amfo) //needs an o_o so we can write outside
//
//   requires kvdReqs(m',k,v,of,ot,cf,ct,m)
//
//   ensures  allmagic2(m)   //a bit slow
//
// //  ensures  dexford4(m)
//
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m)
//   ensures  refOK(of,ot) ==> refOK(cf,ct)
// {
//    assert cf == of;
//    assert ct == ot;
//   allmagic2restored(m',k,v,m);
// }
//
//
//
// lemma {:isolate_assertions}  kvdOI(m' : Klon, k : Object, v : Object, of : Object, ot : Object, cf : Object, ct: Object, m : Klon, o : Object, c : Object)
//
//    requires of.Ready()
//    requires  o.Ready()
//    requires ot.Ready()
//
//   requires not(of.AMFO >= m'.o_amfo) //needs an o_o so we can write inside...
//   requires    (ot.AMFO >= m'.o_amfo) //needs an o_o so we can write inside...
//
//   requires kvdReqs(m',k,v,of,ot,cf,ct,m)
//
//   requires k !in m'.m.Keys
//   requires v !in m'.m.Values
//
//   requires o in m'.m.Keys
//   requires c == m'.m[o]
//   requires o.AMFO == m'.o_amfo
//   requires c.AMFO == m'.c_amfo
//
//   requires  o.AMFX == c.AMFX
// //wanted ensures  (o.AMFO - {o}) == (c.AMFO - {c})  //doesnt allow clone to be pushed down
//
// //KJX but outside stuff arent update by clone - should this be inside(of, o) ==> (refOK(of,ot) ==> refOK(cf,ct))
// //KJX but outside stuff arent update by clone - should this be inside(of, o) ==> (refOK(of,ot) ==> refOK(cf,ct))
// //KJX but outside stuff arent update by clone - should this be inside(of, o) ==> (refOK(of,ot) ==> refOK(cf,ct))
//
// //wanted but slows everything down
// // ensures  allmagic2(m)
//
//
//   //wanted but slows everything down
//   // ensures  dexy_NO_builtin(of,ot,cf,ct,m)
//   // ensures  refOK(of,ot) ==> refOK(cf,ct)
// {
//    assert of == cf by {
//     assert not( of.AMFO >= m'.o_amfo) by { assert   allmagic2(m'); }
//     }
//    assert of.Ready();
//    assert o.Ready();
//    assert ot.Ready();
//    assert outside(of,o); //&& (f != o) //unnecessary;
//    assert inside(ot,o);  //&& (t != o) //perhaps, perhaps, perhaps  //ieStrictlyInside;
//
// if (not(refOK(of,ot))) {
//     assert not(refOK(of,ot));
//     assert  refOK(of,ot) ==> refOK(cf,ct);
//     return;
//     }
//    assert refOK(of,ot);
//
// //    INCOMING_REFS_OWNER_ONLY(of,ot,o);
//
//     assert ot == o;
//
//     assert cf == of;
//    assert m.m[ot] == ct;
//
//
//    assert refOK(of,ct);
//
//    assert ct.AMFO == m.c_amfo;
//    allmagic2restored(m',k,v,m);
//    assert allmagic2(m);
//
//     assert  dexy_NO_builtin(of,ot,cf,ct,m);
//     assert  refOK(of,ot) ==> refOK(cf,ct);
// }
//
//
// lemma kvdIO(m' : Klon, k : Object, v : Object, of : Object, ot : Object, cf : Object, ct: Object, o : Object, c : Object, m : Klon)
//
//   requires    (of.AMFO >= m'.o_amfo) //needs an o_o so we can write inside...
//   requires not(ot.AMFO >= m'.o_amfo) //needs an o_o so we can write inside...
//
//   requires kvdReqs(m',k,v,of,ot,cf,ct,m)
// /////////////////////////////////////////////////////////////////////////
//   requires k !in m'.m.Keys
//   requires v !in m'.m.Values
//
//   requires o in m'.m.Keys
//   requires c == m'.m[o]
//   requires o.AMFO == m'.o_amfo
//   requires c.AMFO == m'.c_amfo
//   requires cf.AMFB >= of.AMFB
//
//   requires  o.AMFX == c.AMFX
//   ensures  (o.AMFO - {o}) == (c.AMFO - {c})  //doesnt allow clone to be pushed down
//
// //KJX but outside stuff arent update by clone - should this be inside(of, o) ==> (refOK(of,ot) ==> refOK(cf,ct))
// //KJX but outside stuff arent update by clone - should this be inside(of, o) ==> (refOK(of,ot) ==> refOK(cf,ct))
// //KJX but outside stuff arent update by clone - should this be inside(of, o) ==> (refOK(of,ot) ==> refOK(cf,ct))
//
// /////////////////////////////////////////////////////////////////////////
// //corret but slow ensures  allmagic2(m)
// //
//   //  ensures  dexy_NO_builtin(of,ot,cf,ct,m)
//   //  ensures  refOK(of,ot) ==> refOK(cf,ct)
// {
//   assert magic2(k,v,m');
//   assert ot == ct;
// //
//   if (refOK(of,ot)) {
//     assert of != ot;
//     assert not(refDI(of,ot));
//     assert refBI(of,ot);
//     assert of.AMFB >= ot.AMFX;
//
//     assert cf.AMFB >= of.AMFB;
//     assert ct.AMFX == ot.AMFX;
//     assert cf.AMFB >= ct.AMFX;
//     assert refBI(cf,ct);
//     assert refOK(cf,ct);
//   }
//
//    allmagic2restored(m',k,v,m);
// }
//
//
// lemma {:isolate_assertions} kvdII(m' : Klon, k : Object, v : Object, of : Object, ot : Object, cf : Object, ct: Object, m : Klon)
//
//   requires kvdReqs(m',k,v,of,ot,cf,ct,m)
//
//   requires forall k <- m'.m.Keys :: k.owner <= m'.m.Keys   //IN-KLON
//   requires forall k <- m'.m.Keys :: k.AMFO  <= m'.m.Keys   //IN-KLON
//   requires m'.o_amfo <= m'.m.Keys  //IN-KLON
//
//   requires forall o <- m.m.Keys :: && (o.AMFO <= m.m.Keys) && (o.bound <= m.m.Keys) && (o.owner <= m.m.Keys) && (o.ntrnl <= m.m.Keys) //IN-KLON
//
//   requires k.owner <= m.m.Keys   //IN-KLON
//   requires k.AMFO  <= m.m.Keys   //IN-KLON
//   requires klownersMapOK(k,v,m)
//
//   requires objectOwnersWithinKlonOK(of,m)
//   requires objectOwnersWithinKlonOK(ot,m)
//   requires objectOwnersWithinKlonOK(cf,m)
//   requires objectOwnersWithinKlonOK(ct,m)
//
//   requires allmagic2(m')
//   requires allKlownersMapOK(m')
//
//   requires    (of.AMFO >= m'.o_amfo) //needs an o_o so we can write inside...
//   requires    (ot.AMFO >= m'.o_amfo)
//    //this means of & ot are both inside: k will be one or other of them...
//
//   // ensures  allmagic2(m) //working?? but tricky
//   // ensures  allKlownersMapOK(m)
//
//   requires dexford4(m')
// //  ensures  dexford4(m)
// //
// //   ensures  dexy_NO_builtin(of,ot,cf,ct,m)
//   // ensures  refOK(of,ot) ==> refOK(cf,ct)
// {
//   assert kvdReqs(m',k,v,of,ot,cf,ct,m);
//
//   assert
//   && {of, ot} <= m.m.Keys
//   && m.m[of] == cf
//   && m.m[ot] == ct
//   ;
//
//   assert m.from(m');
//   assert klownersMapOK(k,v,m);
//
//   allmagic2restored(m',k,v,m);
//   AllKlownersMapKVRestored(m',k,v,m);
//
//
//   assert allKlownersMapOK(m);
//
//   assert k in m.m.Keys;
//   assert v in m.m.Values;
//   assert m.m[k] == v;
//   assert m.o_amfo <= m.m.Keys;
//   assert k.owner <= m.m.Keys;
//   assert k.AMFO  <= m.m.Keys;
//
//   assert {k, of, ot} <= m.m.Keys;
//   assert {v, cf, ct} <= m.m.Values;
//
//   // assert klownersInsideOK(of,ot,cf,ct,m');
//   // assert(inside(of,ot) ==> inside(cf,ct));
//      if (refOK(of,ot)) {
//
// AllKlownersPreservesOwnership(m);
//
// //assert forall i <- m.m.Keys, j <- m.m.Keys ::  (klownersInsideOK(i,j,m.m[i],m.m[j],m));
// assert forall i <- m.m.Keys, j <- m.m.Keys :: (inside(i,j) ==> inside(m.m[i],m.m[j]));
//
// assert forall i <- m.m.Keys, j <- m.m.Keys :: (inside(i,j) ==> inside(m.m[i],m.m[j]));
//
// assert M3K: klownersMapOK(k,v,m);
// assert M3F: klownersMapOK(of,cf,m);
// assert M3T: klownersMapOK(ot,ct,m);
//
//   assert
//   && {of, ot} <= m.m.Keys
//   && m.m[of] == cf
//   && m.m[ot] == ct
//   ;
//
// fuckenHell3(of,ot,cf,ct,m);
//
//
//
// // assert (inside(of,ot) ==> inside(cf,ct));
// // //
// // //     //continue here!
// // //     //continue here!
// // //     //continue here!
// // //     //continue here!
// // // //
// // // //         assert (of.AMFO >= m.o_amfo) && (ot.AMFO >= m.o_amfo);
// // // //         assert cf.AMFO >= m.c_amfo;
// // // //         assert ct.AMFO >= m.c_amfo;
// //
// //   if (of == ot) {
// //     assert refOK(of,ot);
// //     assert refOK(cf,ct);
// //     return;
// //   }
// //
// //   if (refDI(of,ot)) {
// //     assert refOK(of,ot);
// //     assert (of.AMFO == ot.AMFX);
// //     assert klownersMapOK(of,cf,m) by { reveal M3F; }
// //     assert mapThruKlowners(of,m) == cf.AMFO;
// //     assert cf.Ready();
// //     assert klownersMapOK(ot,ct,m) by { reveal M3T; }
// //     assert mapThruKlowners(ot,m) == ct.AMFO;
// //     assert ct.Ready();
// //     assert ct.AMFX == ct.AMFO - {ct};
// //
// //
// //   //  assert refOK(cf,ct);
// //     return;
// //   }
// //
// //   if (refBI(of,ot)) {
// //     assert refOK(of,ot);
// //     assert klownersMapOK(of,cf,m) by { reveal M3F; }
// //     assert klownersMapOK(ot,ct,m) by { reveal M3T; }
// //   //  assert refOK(cf,ct);
// //     return;
// //    }
// //
// //    assert {:contradiction} not(refOK(of,ot));
// //    assert {:contradiction} false;
// //
// // //
// //    }
// // //
//      }
// //////////////////////////////t  assert refOK(of,ot) ==> refOK(cf,ct);
// }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// //extrabit#1
// //         if (ot.AMFO >= m.o_amfo) //inside
// //          { assert ((ot != ct) && (ct.AMFO >= m.c_amfo));
// //            assert refOK(of,ot);
// //            assert refOK(cf,ct); }
//
//



predicate {:isolate_assertions} klownersInsideOK(of : Object, ot : Object, cf : Object, ct: Object, m : Klon) : ( rv : bool )
  requires {of, ot} <= m.m.Keys
  requires m.m[of] == cf
  requires m.m[ot] == ct

  //requires allmagic(m)
  // requires magic2(of,cf,m)
  // requires magic2(ot,ct,m)

//  requires (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) <==> (m.m[x] == x)))
  //seems not to requires ANY other constraints than this one...
//
//   requires (of != cf) ==> (cf.AMFO >= m.c_amfo)
//   requires (ot != ct) ==> (ct.AMFO >= m.c_amfo)


  ensures rv == (inside(of,ot) ==> inside(cf,ct))
{
(inside(of,ot) ==> inside(cf,ct))
}

















//
//
//
//
// predicate wexy(of : Object, ot : Object, cf : Object, ct: Object, m : SuperKlon) : ( rv : bool )
// //note doesnt requrie Valid???
// // this Kklon has wexford2()  BUILT IN@!!A
//   requires {of, ot} <= m.m.Keys
//   requires m.m[of] == cf
//   requires m.m[ot] == ct
//
//   requires (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) <==> (m.m[x] == x)))
//
//   requires (of != cf) ==> (cf.AMFO >= m.c_amfo)
//   requires (ot != ct) ==> (ct.AMFO >= m.c_amfo)
//
//   ensures rv == (refOK(of,ot) ==> refOK(cf,ct))
// {
//
//   // 25DEC 2024 - starting on the 2x2 version inside/outside of ,ot cases
//   //
//   if (not(of.AMFO >= m.o_amfo))
//     then //from outside
//       (if (not(ot.AMFO >= m.o_amfo)) then (
//         //both outside
//         assert (not(of.AMFO >= m.o_amfo)) && (not(ot.AMFO >= m.o_amfo));
//         assert of == cf;
//         assert ot == ct;
//         refOK(of,ot) ==> refOK(cf,ct)
//       ) else (
//         //from outside to inside...
//         assert (not(of.AMFO >= m.o_amfo)) && (ot.AMFO >= m.o_amfo);
//         assert of == cf;
//         assert ct.AMFO >= m.c_amfo;
//         refOK(of,ot) ==> refOK(cf,ct)))
//     else //from inside
//       (if (not(ot.AMFO >= m.o_amfo)) then (
//         //from inside to outside
//         assert (of.AMFO >= m.o_amfo) && (not(ot.AMFO >= m.o_amfo));
//         assert cf.AMFO >= m.c_amfo;
//         assert ot == ct;
//         refOK(of,ot) ==> refOK(cf,ct)
//       ) else (
//         //both inside
//         assert (of.AMFO >= m.o_amfo) && (ot.AMFO >= m.o_amfo);
//         assert cf.AMFO >= m.c_amfo;
//         assert ct.AMFO >= m.c_amfo;
//         refOK(of,ot) ==> refOK(cf,ct)))
// }
//
//
//
//
// predicate wexy_NO_builtin(of : Object, ot : Object, cf : Object, ct: Object, m : Klon) : ( rv : bool )
//
//   // requires {of, ot} <= m.m.Keys
//   // requires m.m[of] == cf
//   // requires m.m[ot] == ct
//
//   //requires allmagic(m)
//   requires magic2(of,cf,m)
//   requires magic2(ot,ct,m)
//
// //  requires (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) <==> (m.m[x] == x)))
//   //seems not to requires ANY other constraints than this one...
// //
// //   requires (of != cf) ==> (cf.AMFO >= m.c_amfo)
// //   requires (ot != ct) ==> (ct.AMFO >= m.c_amfo)
//
//
//   ensures rv == (refOK(of,ot) ==> refOK(cf,ct))
// {
//
//   // 25DEC 2024 - starting on the 2x2 version inside/outside of ,ot cases
//   //
//   if (not(of.AMFO >= m.o_amfo))
//     then //from outside
//       (if (not(ot.AMFO >= m.o_amfo)) then (
//         //both outside
//         assert (not(of.AMFO >= m.o_amfo)) && (not(ot.AMFO >= m.o_amfo));
//         assert of == cf;
//         assert ot == ct;
//         refOK(of,ot) ==> refOK(cf,ct)
//       ) else (
//         //from outside to inside...
//         assert (not(of.AMFO >= m.o_amfo)) && (ot.AMFO >= m.o_amfo);
//         assert of == cf;
//         assert ct.AMFO >= m.c_amfo;
//         refOK(of,ot) ==> refOK(cf,ct)))
//     else //from inside
//       (if (not(ot.AMFO >= m.o_amfo)) then (
//         //from inside to outside
//         assert (of.AMFO >= m.o_amfo) && (not(ot.AMFO >= m.o_amfo));
//         assert cf.AMFO >= m.c_amfo;
//         assert ot == ct;
//         refOK(of,ot) ==> refOK(cf,ct)
//       ) else (
//         //both inside
//         assert (of.AMFO >= m.o_amfo) && (ot.AMFO >= m.o_amfo);
//         assert cf.AMFO >= m.c_amfo;
//         assert ct.AMFO >= m.c_amfo;
//         refOK(of,ot) ==> refOK(cf,ct)))
// }
//
//
//
//
// predicate dexy(of : Object, ot : Object, cf : Object, ct: Object, m : SuperKlon) : ( rv : bool )
// //  requires wexford3(m)
// /// HMM doesit still work?
// // agan doesn't need Valid??
// // this Kklon has wexford2()  BUILT IN !!A
//   // requires {of, ot} <= m.m.Keys
//   // requires m.m[of] == cf
//   // requires m.m[ot] == ct
//
//   // requires (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) <==> (m.m[x] == x)))
//
//   ensures rv == (refOK(of,ot) ==> refOK(cf,ct))
// {
//
//   // 25DEC 2024 - version done by case analysis of the refOK(of,ot)
//   //
//
//   if (of == ot) then (
//     assert refOK(of,ot);
//     refOK(cf,ct)) else (
//   if (refDI(of,ot)) then (
//     assert refOK(of,ot);
//     refOK(cf,ct)) else (
//   if (refBI(of,ot)) then (
//     assert refOK(of,ot);
//     refOK(cf,ct)
//   ) else (
//     assert not(refOK(of,ot));
//     true)))
// }
//
//
//
// predicate dexy_NO_builtin(of : Object, ot : Object, cf : Object, ct: Object, m : Klon) : ( rv : bool )
// //no builtin constraints version
//   // requires {of, ot} <= m.m.Keys
//   // requires m.m[of] == cf
//   // requires m.m[ot] == ct
//
//   // requires (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) <==> (m.m[x] == x)))
//
//   ensures rv == (refOK(of,ot) ==> refOK(cf,ct))
// {
//
//   // 25DEC 2024 - version done by case analysis of the refOK(of,ot)
//   //
//
//   if (of == ot) then (
//     assert refOK(of,ot);
//     refOK(cf,ct)) else (
//   if (refDI(of,ot)) then (
//     assert refOK(of,ot);
//     refOK(cf,ct)) else (
//   if (refBI(of,ot)) then (
//     assert refOK(of,ot);
//     refOK(cf,ct)
//   ) else (
//     assert not(refOK(of,ot));
//     true)))
// }
//
//
//
// lemma compare_NO_builtin(of : Object, ot : Object, cf : Object, ct: Object, m : Klon)
//
//   requires allmagic2(m)
//
//   requires {of, ot} <= m.m.Keys
//   requires m.m[of] == cf
//   requires m.m[ot] == ct
//
// //   requires (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) <==> (m.m[x] == x)))
// //
// //   requires (of != cf) ==> (cf.AMFO >= m.c_amfo)
// //   requires (ot != ct) ==> (ct.AMFO >= m.c_amfo)
//
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m)  ==> wexy_NO_builtin(of,ot,cf,ct,m)
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m) <==  wexy_NO_builtin(of,ot,cf,ct,m)
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m) <==> wexy_NO_builtin(of,ot,cf,ct,m)
//
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m)  ==> cexy_NO_builtin(of,ot,cf,ct,m)
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m) <==  cexy_NO_builtin(of,ot,cf,ct,m)
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m) <==> cexy_NO_builtin(of,ot,cf,ct,m)
//
//   ensures  wexy_NO_builtin(of,ot,cf,ct,m)  ==> cexy_NO_builtin(of,ot,cf,ct,m)
//   ensures  wexy_NO_builtin(of,ot,cf,ct,m) <==  cexy_NO_builtin(of,ot,cf,ct,m)
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m) <==> cexy_NO_builtin(of,ot,cf,ct,m)
//
//   ensures  dexy_NO_builtin(of,ot,cf,ct,m)
//       == cexy_NO_builtin(of,ot,cf,ct,m)
//       == wexy_NO_builtin(of,ot,cf,ct,m)
//
// {
// //
// // assert  dexy_NO_builtin(of,ot,cf,ct,m) <==> wexy_NO_builtin(of,ot,cf,ct,m);
// // assert  dexy_NO_builtin(of,ot,cf,ct,m) <==> cexy_NO_builtin(of,ot,cf,ct,m);
// // assert  dexy_NO_builtin(of,ot,cf,ct,m) <==> cexy_NO_builtin(of,ot,cf,ct,m);
// // assert  dexy_NO_builtin(of,ot,cf,ct,m)
// //       == cexy_NO_builtin(of,ot,cf,ct,m)
// //       == wexy_NO_builtin(of,ot,cf,ct,m);
//
// }
//
// predicate cexy_NO_builtin(of : Object, ot : Object, cf : Object, ct: Object, m : Klon)
// //
// //   requires {of, ot} <= m.m.Keys
// //   requires m.m[of] == cf
// //   requires m.m[ot] == ct
//
// {
//    refOK(of,ot) ==> refOK(cf,ct)
// }

predicate klownersMapOK(k : Object, v : Object, m : Klon) : ( rv : bool )
//see allKlownersMapOK for why k & v must be in m already
  requires k in m.m.Keys
  requires v in m.m.Values
  requires m.m[k] == v
  requires m.o_amfo <= m.m.Keys   //IN-KLON
  requires k.owner <= m.m.Keys   //IN-KLON
  requires k.AMFO  <= m.m.Keys   //IN-KLON
{
  var CXTRA := m.c_amfo - mapThruKlon(m.o_amfo, m);
  var OXTRA := mapThruKlon(m.o_amfo, m) - m.c_amfo;


  assert  mapThruKlon(m.o_amfo, m) - OXTRA + CXTRA == m.c_amfo;

///KJX continue from here - needs to be done in parallel for owner & AMFO!
///KJX continue from here - needs to be done in parallel for owner & AMFO!
///KJX continue from here - needs to be done in parallel for owner & AMFO!

  && (v.AMFO == (mapThruKlon(k.AMFO, m) - OXTRA + CXTRA )) //and this one???
}


function  mapThruKlowners(k : Object, m : Klon) : Owner
  requires k in m.m.Keys
  // requires v in m.m.Values
  // requires m.m[k] == v
  requires m.o_amfo <= m.m.Keys   //IN-KLON
  requires k.owner <= m.m.Keys   //IN-KLON
  requires k.AMFO  <= m.m.Keys   //IN-KLON

{
  var CXTRA := m.c_amfo - mapThruKlon(m.o_amfo, m);
  var OXTRA := mapThruKlon(m.o_amfo, m) - m.c_amfo;

assert  (mapThruKlon(m.o_amfo, m) - OXTRA + CXTRA) == m.c_amfo;

///KJX continue from here - needs to be done in parallel for owner & AMFO!
///KJX continue from here - needs to be done in parallel for owner & AMFO!
///KJX continue from here - needs to be done in parallel for owner & AMFO!

  (mapThruKlon(k.AMFO, m) - OXTRA + CXTRA ) //and this one??
}


function mapKlowners(k : Owner, m : Klon) : Owner
  requires m.o_amfo <= m.m.Keys   //IN-KLON
  requires k <= m.m.Keys
{
  var CXTRA := m.c_amfo - mapThruKlon(m.o_amfo, m);
  var OXTRA := mapThruKlon(m.o_amfo, m) - m.c_amfo;

  (mapThruKlon(k,m) - OXTRA + CXTRA )
}

lemma MapKlownersThruKlowners(k : Object, m : Klon)
  requires k in m.m.Keys
  // requires v in m.m.Values
  // requires m.m[k] == v
  requires m.o_amfo <= m.m.Keys   //IN-KLON
  requires k.owner <= m.m.Keys   //IN-KLON
  requires k.AMFO  <= m.m.Keys   //IN-KLON
  ensures  mapThruKlowners(k,m) == mapKlowners(k.AMFO, m)
  {}


predicate objectOwnerAttributesMapOK(o : Object, m : Klon)
  requires m.o_amfo <= m.m.Keys   //IN-KLON
  requires m.m.Keys >= o.ntrnl > o.owner >= o.bound
  requires m.m.Keys >= o.AMFO  > o.AMFX  >= o.AMFB
  requires o in m.m.Keys
{
  var c := m.m[o];

  && (c.bound == mapKlowners(o.bound, m))
  && (c.AMFB  == mapKlowners(o.AMFB,  m))
  && (c.owner == mapKlowners(o.owner, m))
  && (c.AMFX  == mapKlowners(o.AMFX , m))
  && (c.ntrnl == mapKlowners(o.ntrnl, m))
  && (c.AMFO  == mapKlowners(o.AMFO,  m))
}




lemma  MapKlownersMapsOK1(k : Object, v : Object, m : Klon)
  requires k in m.m.Keys
  requires v in m.m.Values
  requires m.m[k] == v
  requires m.o_amfo <= m.m.Keys   //IN-KLON
  requires k.owner <= m.m.Keys   //IN-KLON
  requires k.AMFO  <= m.m.Keys   //IN-KLON
  requires klownersMapOK(k,v,m)
  ensures (
    var mTKoA := mapThruKlon(m.o_amfo, m);
    var CXTRA := m.c_amfo - mTKoA;
    var OXTRA := mTKoA - m.c_amfo;
    && ((mTKoA - OXTRA + CXTRA) == m.c_amfo)
    && (v.AMFO == mapThruKlowners(k,m))
  )
{
    var mTKoA := mapThruKlon(m.o_amfo, m);
    var CXTRA := m.c_amfo - mTKoA;
    var OXTRA := mTKoA - m.c_amfo;
    assert
      && ((mTKoA - OXTRA + CXTRA) == m.c_amfo)
      && (v.AMFO == mapThruKlowners(k,m))
      ;
}

lemma MapKlownersMapsOK2(m : Klon, o : Object, c : Object)
  requires o.AMFO == m.o_amfo
  requires c.AMFO == m.c_amfo
  requires o in m.m.Keys
  requires c in m.m.Values
  requires m.m[o] == c
//see allKlownersMapOK for why k & v must be in m already
  requires forall k <- m.m.Keys :: k.owner <= m.m.Keys   //IN-KLON
  requires forall k <- m.m.Keys :: k.AMFO  <= m.m.Keys   //IN-KLON
  requires allKlownersMapOK(m)
  requires m.o_amfo <= m.m.Keys
  requires m.c_amfo == m.m[o].AMFO
  ensures  klownersMapOK(o, c, m)
{}


predicate allKlownersMapOK(m : Klon)
  requires forall k <- m.m.Keys :: k.owner <= m.m.Keys   //IN-KLON
  requires forall k <- m.m.Keys :: k.AMFO  <= m.m.Keys   //IN-KLON
  requires m.o_amfo <= m.m.Keys   //IN-KLON
{

  forall x <- m.m.Keys :: klownersMapOK(x,m.m[x],m)
}

lemma AllKlownersMapKVRestored(m' : Klon, k : Object, v : Object, m : Klon)
//ensures m'[k := v] == m
//are these *MOT* going to leave Australia to teach someewhwere else?
  requires k !in m'.m.Keys
  requires v !in m'.m.Values
  requires forall k <- m'.m.Keys :: k.owner <= m'.m.Keys   //IN-KLON
  requires forall k <- m'.m.Keys :: k.AMFO  <= m'.m.Keys   //IN-KLON
  requires m'.o_amfo <= m'.m.Keys   //IN-KLON
  requires allKlownersMapOK(m')
  requires m == klonKV(m',k,v)

  requires k.owner <= m.m.Keys   //IN-KLON
  requires k.AMFO  <= m.m.Keys   //IN-KLON
  requires klownersMapOK(k,v,m)

  ensures  allKlownersMapOK(m)
{
  assert v == m.m[k];
  assert forall mm <- m'.m.Keys :: m'.m[mm]  == m.m[mm];
  assert forall mm <- m.m.Keys :: ((mm in m'.m.Keys) ==> (m'.m[mm] == m.m[mm]));
  assert m.m.Keys == m'.m.Keys + {k};

   assert allKlownersMapOK(m');
   assert forall mm <- m'.m.Keys       :: klownersMapOK(mm, m.m[mm], m);
   assert klownersMapOK(k,v,m);
   assert forall mm <- {k}             :: klownersMapOK(mm, m.m[mm], m);
   assert forall mm <- m'.m.Keys + {k} :: klownersMapOK(mm, m.m[mm], m);
   assert forall mm <- m.m.Keys        :: klownersMapOK(mm, m.m[mm], m);
   assert allKlownersMapOK(m);
}


lemma AllKlownersPreservesOwnership(m : Klon)
  requires forall k <- m.m.Keys :: k.owner <= m.m.Keys   //IN-KLON
  requires forall k <- m.m.Keys :: k.AMFO  <= m.m.Keys   //IN-KLON
  requires m.o_amfo <= m.m.Keys
  requires allKlownersMapOK(m)
  ensures forall i <- m.m.Keys, j <- m.m.Keys ::  (klownersInsideOK(i,j,m.m[i],m.m[j],m))
  {
assert forall i <- m.m.Keys :: klownersMapOK(i,m.m[i],m);

forall i <- m.m.Keys, j <- m.m.Keys
  ensures (klownersInsideOK(i,j,m.m[i],m.m[j],m))
  {
    if (i == j) { return; }
    if (inside(i,j)) {
        assert i.AMFO >= j.AMFO;
        assert klownersMapOK(i,m.m[i], m);
        assert klownersMapOK(j,m.m[j], m);
    }
    assert (klownersInsideOK(i,j,m.m[i],m.m[j],m));
  }
  }




predicate objectOwnersWithinKlonOK(o : Object, m : Klon)
//is o Ready, and all its *owners* in m.Keys?
//(not the lot, just the owners)
{
  && o.Ready()
  && (o in m.m.Keys)
  && (o.AMFO <= m.m.Keys)
  && (o.bound <= m.m.Keys)
  && (o.owner <= m.m.Keys)
  && (o.ntrnl <= m.m.Keys)
}
//
// opaque predicate acertainratio(o : Object, m : Klon)
// {
//   && (m.o_amfo <= m.m.Keys)   //IN-KLON
//   && (m.m.Keys >= o.ntrnl > o.owner >= o.bound)
//   && (m.m.Keys >= o.AMFO  > o.AMFX  >= o.AMFB)
//   && (o in m.m.Keys)
//   && (o.Ready())
// }
//
//
// opaque predicate allcertainratio(m : Klon)
// {
//   forall o <- m.m.Keys :: acertainratio(o,m)
// }
//
//
// lemma fked1(o1 : Object, o2 : Object, m : Klon)
//   requires m.o_amfo <= m.m.Keys   //IN-KLON
//
//   requires m.m.Keys >= o1.ntrnl > o1.owner >= o1.bound
//   requires m.m.Keys >= o1.AMFO  > o1.AMFX  >= o1.AMFB
//   requires o1 in m.m.Keys
//   requires o1.Ready()
//
//   requires m.m.Keys >= o2.ntrnl > o2.owner >= o2.bound
//   requires m.m.Keys >= o2.AMFO  > o2.AMFX  >= o2.AMFB
//   requires o2 in m.m.Keys
//   requires o2.Ready()
//
//   requires (  o1 == o2   )
//   ensures  (  m.m[o1] == m.m[o2]   )
// {}
//
//
// lemma {:isolate_assertions} fked2(o1 : Object, o2 : Object, m : Klon)
//   requires m.o_amfo <= m.m.Keys   //IN-KLON
//   requires o1 in m.m.Keys
//   requires o2 in m.m.Keys
//   requires acrm: allcertainratio(m)
//   requires allcertainratio(m)
//
//   requires forall o <- m.m.Keys :: o.Ready()
// //   ensures  m.m.Keys >= o1.ntrnl > o1.owner >= o1.bound
// //   ensures  m.m.Keys >= o1.AMFO  > o1.AMFX  >= o1.AMFB
// //   ensures  o1 in m.m.Keys
// //   ensures  o1.Ready()
// //
// //   ensures  m.m.Keys >= o2.ntrnl > o2.owner >= o2.bound
// //   ensures  m.m.Keys >= o2.AMFO  > o2.AMFX  >= o2.AMFB
// //   ensures  o2 in m.m.Keys
// //  ensures  o2.Ready()
//
//  requires
//    reveal allcertainratio(), acertainratio(), o2.Ready();
//    forall k <- m.m.Keys :: objectOwnerAttributesMapOK(k, m)
//
// //  requires (inside(o1,o2))
// //  ensures  (inside(m.m[o1],m.m[o2]))
//
// //  requires (refDI(o1,o2))
// //  ensures  (refDI(m.m[o1],m.m[o2]))
//
// //  requires (refBI(o1,o2))
// //  ensures  (refBI(m.m[o1],m.m[o2]))
//
//  requires (refOK(o1,o2))
//  ensures  (refOK(m.m[o1],m.m[o2]))
// {
//   assert allcertainratio(m) by { reveal acrm;}
//   assert o2 in m.m.Keys;
//   assert acertainratio(o2,m) by { reveal acrm, allcertainratio(); }
//   assert
//     var o := o2;
//       && (m.o_amfo <= m.m.Keys)   //IN-KLON
//       && (m.m.Keys >= o.ntrnl > o.owner >= o.bound)
//       && (m.m.Keys >= o.AMFO  > o.AMFX  >= o.AMFB)
//       && (o in m.m.Keys)
//       by { reveal acrm, allcertainratio(), acertainratio(); }
//    assert o2 in m.m.Keys && o2.Ready() by { reveal acrm, allcertainratio(), acertainratio(), o2.Ready(); }
//
//   assert  (refOK(m.m[o1],m.m[o2]));
// }
//
//
//
// lemma {:isolate_assertions}  fuckenHell2(a : Object, b : Object, c : Object, d : Object, aa : Owner, bb : Owner, cc : Owner, dd : Owner, m : Klon)
//   requires objectOwnersWithinKlonOK(a,m)
//   requires objectOwnersWithinKlonOK(b,m)
//   requires objectOwnersWithinKlonOK(c,m)
//   requires objectOwnersWithinKlonOK(d,m)
//
//   requires m.o_amfo <= m.m.Keys
//   requires aa == mapThruKlowners(a, m)
//   requires bb == mapThruKlowners(b, m)
//   requires cc == aa - bb
//   requires dd == mapThruKlon(a.AMFO - b.AMFO, m)
//
//   ensures  cc <= dd
// {}
//
//
// lemma {:isolate_assertions} fuckenHell3(a : Object, b : Object, c : Object, d : Object, m : Klon)
//   requires objectOwnersWithinKlonOK(a,m)
//   requires objectOwnersWithinKlonOK(b,m)
//   requires objectOwnersWithinKlonOK(c,m)
//   requires objectOwnersWithinKlonOK(d,m)
//
//   requires m.o_amfo <= m.m.Keys
//   requires forall o <- m.m.Keys ::
//       && (o.AMFO <= m.m.Keys)
//       && (o.bound <= m.m.Keys)
//       && (o.owner <= m.m.Keys)
//       && (o.ntrnl <= m.m.Keys)
//
//   requires allKlownersMapOK(m)
// //
// //   requires b != c
// //   requires b != d
// //   requires c != d
//
//   requires c == m.m[a]
//   requires d == m.m[b]
//
// //WORKS..
// // requires inside(b,a)
// // ensures  inside(d,c)
//
// //also fuckenj works
// // requires a == b  // inside(b,a)
// // ensures  c == d  // inside(d,c)
//
// //DOSNT FUCKEN WORK... WHY???
// // requires refOK(a,b) // a == b  // inside(b,a)
// // ensures  refOK(c,d) // c == d  // inside(d,c)
//
// // //WORKS!!!
// // requires refDI(a,b)
// // ensures  refDI(c,d)
// //
// // DOENST FUCKWN WORKS FUCKER!!
// // requires refBI(a,b)
// // ensures  refBI(c,d)
//
// //SHOULD WORK NOWWW?? DOESNTT...
// // requires refOK(a,b) // a == b  // inside(b,a)
// // ensures  refOK(c,d) // c == d  // inside(d,c)
// {
//   // if (  a == b  ) { assert   a == b  ; assert refOK(c,d); return;}
//   // if (refDI(a,b)) { assert refDI(c,d); assert refOK(c,d); return;}
//   // if (refBI(a,b)) { assert refBI(c,d); assert refOK(c,d); return;}
//
// }
// //
// //
//
// predicate magic3old(k : Object, v : Object, m : Klon) : ( rv : bool )
//
//   requires k !in m.m.Keys
//   requires v !in m.m.Values
//
//   //  requires (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) <==> (m.m[x] == x)))
//
// //  requires (k != v) ==> (v.AMFO >= m.c_amfo)
// {
//   //  && (if (k.AMFO >= m.o_amfo)
//   //       then ((v != k) && (v.AMFO >= m.c_amfo))
//   //       else ((v == k)))
//   //  && ((k.AMFX == m.o_amfo) ==> (v.AMFX == m.c_amfo))
//
//    && ((k !in m.m.Keys) && (v !in m.m.Values))
//
//    && (var satam := klonKV(m, k, v);
//     forall i <- m.m.Keys, j <- m.m.Keys :: klownersInsideOK(i,j,satam.m[i],satam.m[j],satam))
// }
//
// predicate magic2(k : Object, v : Object, m : Klon) : ( rv : bool )
//
//   //  requires (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) <==> (m.m[x] == x)))
//
// //  requires (k != v) ==> (v.AMFO >= m.c_amfo)
// {
//    && (if (k.AMFO >= m.o_amfo)
//         then ((v != k) && (v.AMFO >= m.c_amfo))
//         else ((v == k)))
//    && ((k.AMFX == m.o_amfo) ==> (v.AMFX == m.c_amfo))
// }
//
// lemma allmagic2restored(m' : Klon, k : Object, v : Object, m : Klon)
//   requires k !in m'.m.Keys
//   requires v !in m'.m.Values
//   requires allmagic2(m')
//   requires magic2(k,v,m')
//   requires m == klonKV(m',k,v)
//   ensures  allmagic2(m)
// {
//   assert v == m.m[k];
//   assert forall mm <- m'.m.Keys :: m'.m[mm]  == m.m[mm];
//   assert forall mm <- m.m.Keys :: ((mm in m'.m.Keys) ==> (m'.m[mm] == m.m[mm]));
//   assert m.m.Keys == m'.m.Keys + {k};
//
//    assert allmagic2(m');
//    assert forall mm <- m'.m.Keys       :: magic2(mm, m.m[mm], m);
//    assert magic2(k,v,m);
//    assert forall mm <- {k}             :: magic2(mm, m.m[mm], m);
//    assert forall mm <- m'.m.Keys + {k} :: magic2(mm, m.m[mm], m);
//    assert forall mm <- m.m.Keys        :: magic2(mm, m.m[mm], m);
//    assert allmagic2(m);
// }

//
// predicate magic(k : Object, v : Object, m : Klon) : ( rv : bool )
//
// //  requires (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) <==> (m.m[x] == x)))
//
// //  requires (k != v) ==> (v.AMFO >= m.c_amfo)
// {
//       (if (k.AMFO >= m.o_amfo)
//         then ((v != k) && (v.AMFO >= m.c_amfo))
//         else ((v == k)))
// }
//

// predicate allmagic2(m : Klon)
// {
//   forall x <- m.m.Keys :: magic2(x,m.m[x],m)
// }

// predicate allmagic(m : Klon)
// {
//   forall x <- m.m.Keys :: magic(x,m.m[x],m)
// }
//
// lemma wexford3allmagic(m : Klon)
//   ensures allmagic(m) == wexford3(m)
// {}

//
// predicate cexford4(m : Klon)
// {
//   && (forall i <- m.m.Keys, j <- m.m.Keys :: cexy_NO_builtin(i,j,m.m[i],m.m[j],m))
// }
//
//
// predicate dexford4(m : Klon)
// {
//   && (forall i <- m.m.Keys, j <- m.m.Keys :: dexy_NO_builtin(i,j,m.m[i],m.m[j],m))
// }
//
// predicate wexford4(m : Klon)
//   requires allmagic2(m)
// {
//   && (forall i <- m.m.Keys, j <- m.m.Keys :: wexy_NO_builtin(i,j,m.m[i],m.m[j],m))
// }

// lemma four4(m : Klon)
//   requires allmagic2(m)
//   ensures  cexford4(m) == dexford4(m) == wexford4(m)
// {}
//
//


// predicate wexford3(m : Klon)
// //did its job but by now well obsolete...
// {
//   // && (m.m.Keys   <= m.c)
//   // && (m.m.Values <= m.c)
//
//
//   && (forall x <- m.m.Keys ::
//       (if (x.AMFO >= m.o_amfo)
//         then ((m.m[x] != x) && (m.m[x].AMFO >= m.c_amfo))
//         else ((m.m[x] == x))))
//
//   // && (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) <==> (m.m[x] == x)))
//
// // && (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) ==> (m.m[x] == x)))
//
// //  && (forall i <- m.m.Keys, j <- m.m.Keys :: wexy(i,j,m.m[i],m.m[j],m))
//
// }

//
// predicate wexford2(m : Klon)
// // note this is built into the SuperKlon
// {
//   // && (m.m.Keys   <= m.c)
//   // && (m.m.Values <= m.c)
//   && (forall x <- m.m.Keys :: (not(x.AMFO >= m.o_amfo) ==> (m.m[x] == x)))
//   && (forall i <- m.m.Keys, j <- m.m.Keys :: refOK(i,j) ==> refOK(m.m[i],m.m[j]))
// }

// TO DELETE
//
// predicate wexford(m : SuperKlon)
// { forall i <- m.m.Keys, j <- m.m.Keys :: refOK(i,j) ==> refOK(m.m[i],m.m[j]) }
//
// predicate waterford(m : SuperKlon)
// { forall i <- m.m.Keys, j <- m.m.Keys |  refOK(i,j) ::  refOK(m.m[i],m.m[j]) }
//
// lemma wexwater(m : SuperKlon)
//   ensures wexford(m) == waterford(m)
// {}



//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
// copied from Library
//
type vmap<K,V> = u : map<K,V> | AllMapEntriesAreUnique(u)


predicate AllMapEntriesAreUnique<K,V(==)>(m : map<K,V>)
{
    forall i <- m.Keys, j <- m.Keys :: (m[i] == m[j]) ==> (i == j)
}

predicate not(x : bool) { !x }

lemma skip() {}

predicate mapLEQ<K(==),V(==)>(left : map<K,V>, right : map<K,V>)
{
  (forall k <- left.Keys :: k in right && (left[k] == right[k]))
}

predicate mapGEQ<K(==),V(==)>(left : map<K,V>, right : map<K,V>)
{
  (forall k <- right.Keys :: k in left && (left[k] == right[k]))
}